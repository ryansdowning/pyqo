import { useEffect, useState } from "react";

import createClient, { ClientMethod } from "openapi-fetch";
import { HttpMethod, MediaType } from "openapi-typescript-helpers";
import { useLocalStorage } from "usehooks-ts";

import { notifications } from "@mantine/notifications";

import type { paths } from "../schema"; // generated by openapi-typescript
import { drfErrorToString } from "./format";

export const BASE_URL = "http://127.0.0.1:8000";
export const client = createClient<paths>({ baseUrl: BASE_URL });
export const PAGE_SIZE = 25;

type DisjointSuccess<Data, Error> =
  | {
      success: true;
      data: Data;
    }
  | { success: false; error: Error };

interface UseQueryOptions<Result, Data, Failure> {
  executeQuery: () => Promise<Result>;
  getDataOrErrorFromResponse: (
    result: Result
  ) => DisjointSuccess<Data, Failure>;
}

function useQuery<Result, Data>({
  executeQuery,
  getDataOrErrorFromResponse,
}: UseQueryOptions<Result, Data, string>) {
  const [fetching, setFetching] = useState(false);
  const [data, setData] = useState<Data | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    setFetching(true);
    executeQuery()
      .then(getDataOrErrorFromResponse)
      .then((result) =>
        result.success ? setData(result.data) : setError(result.error)
      )
      .finally(() => setFetching(false));
  }, []);

  return { fetching, data, error };
}

type RouteQueryParams<
  Path extends keyof paths,
  Method extends keyof paths[Path]
> = paths[Path][Method] extends { parameters: { query?: infer Params } }
  ? Params
  : undefined;

type RouteBody<
  Path extends keyof paths,
  Method extends keyof paths[Path]
> = paths[Path][Method] extends {
  requestBody: { content: { "application/json": infer Body } };
}
  ? Body
  : undefined;

// Generic FetchOptions type that dynamically defines `params` and `body`
type FetchOptions<
  Path extends keyof paths,
  Method extends keyof paths[Path]
> = {
  query?: RouteQueryParams<Path, Method>;
  body?: RouteBody<Path, Method>;
};

function useHeaders() {
  const [token] = useLocalStorage("token", "");

  if (!token) {
    return undefined;
  }

  return {
    "Content-Type": "application/json",
    Authorization: `Token ${token}`,
  };
}

type NormalizeMethods<T> = {
  [M in HttpMethod]: M extends keyof T
    ? T[M] extends never | undefined
      ? {}
      : T[M]
    : {};
};

type CompatiblePaths = {
  [P in keyof paths]: NormalizeMethods<paths[P]>;
};

// Define FetchResponseFor with Awaited to unwrap the Promise from ClientMethod's return type
type FetchResponseFor<
  Path extends keyof CompatiblePaths,
  Method extends keyof CompatiblePaths[Path] & HttpMethod,
  Media extends MediaType
> = Method extends HttpMethod
  ? Awaited<ReturnType<ClientMethod<CompatiblePaths, Method, Media>>>
  : never;

type foo = FetchResponseFor<"/app/items/", "get", "application/json">;

function getDataOrErrorFromResponse<
  Result extends { error?: any; data: any },
  Data
>(result: Result): DisjointSuccess<Data, string> {
  if (result.error) {
    const error = drfErrorToString(result.error);
    notifications.show({
      title: "Failed to load codes",
      message: error,
      color: "red",
    });
    return { success: false, error };
  }
  return { success: true, data: result.data };
}

export function useGetItems({ query }: FetchOptions<"/app/items/", "get">) {
  const headers = useHeaders();

  return useQuery({
    executeQuery: () =>
      client.GET("/app/items/", { headers, params: { query } }),
    getDataOrErrorFromResponse: (result) => {
      if (result.error) {
        const error = drfErrorToString(result.error);
        notifications.show({
          title: "Failed to load codes",
          message: error,
          color: "red",
        });
        return { success: false, error };
      }
      return { success: true, data: result.data } as {
        success: true;
        data: typeof result.data;
      };
    },
  });
}
